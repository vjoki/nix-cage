#!/usr/bin/env python
import os
import subprocess
import tempfile
import fcntl
import time
from argparse import ArgumentParser
from pathlib import Path
from os import execve, getcwd, chdir
from os.path import abspath, expanduser, basename, realpath, exists
from shutil import which
from os import environ, sep
from sys import stderr
from functools import reduce
from json import load as json_unmarshal, dumps as json_marshal_str
from pwd import getpwnam
from string import Template
from collections import defaultdict
from typing import NamedTuple

mount_suffixes = [
    "ro",
    "rw",
    "dev",
    "tmpfs"
]

def get_default_config():
    rw = ["."]
    ro = ["/"]
    dev = []
    tmpfs = [
        "/tmp",
        "/home",
        "/run/user",
        "/run/media",
        "/tmp/.private",
    ]

    xdg_runtime_dir = environ.get("XDG_RUNTIME_DIR")
    if xdg_runtime_dir and exists(xdg_runtime_dir):
        tmpfs.append(xdg_runtime_dir)
    else:
        tmpfs.extend(["/run/user/{UID}".format(**environ)]  if "UID"  in environ else [])

    tmpfs.extend(["/run/media/{USER}".format(**environ)]    if "USER" in environ else [])
    tmpfs.extend(["/tmp/.private/{USER}".format(**environ)] if "USER" in environ else [])

    def set_from_env(k, r, key=None):
        if k in environ:
            r[key or k] = environ[k]

    env = {}
    set_from_env("HOME", env)
    set_from_env("TERM", env)
    set_from_env("SHELL", env)
    set_from_env("NIX_REMOTE", env)
    set_from_env("DBUS_SESSION_BUS_ADDRESS", env)
    set_from_env("XDG_RUNTIME_DIR", env)

    if "NIX_REMOTE" not in env:
        nix_local = [
            environ.get("NIX_STORE_DIR", "/nix/store"),
            environ.get("NIX_LOG_DIR",   "/nix/var/log/nix"),
            environ.get("NIX_STATE_DIR", "/nix/var/nix"),
        ]
        rw.extend(list(filter(exists, nix_local)))

    args = {
        "devtmpfs": [],
        "bwrap": [
            "--new-session",
            "--die-with-parent",
            "--unshare-ipc",
            "--unshare-cgroup",
            "--unshare-uts",
            "--unshare-pid",
            "--hostname", "localhost"
        ],
        "nix-develop": [],
    }
    set_from_env("SHELL", args, key="command")

    return {
        "mode": "expand",
        "dbus": {
            "system": {
                "see": [],
                "talk": [],
                "own": [],
                "call": [],
                "broadcast": [],
            },
            "session": {
                "see": [],
                "talk": [],
                "own": [],
                "call": [],
                "broadcast": [],
            },
        },
        "mounts": {
            "rw":    rw,                           # [(from, to), (from, to), ...] | [to, to, ...]
            "ro":    ro,                           # [(from, to), (from, to), ...] | [to, to, ...]
            "dev":   dev,                          # [(from, to), (from, to), ...] | [to, to, ...]
            "tmpfs": list(filter(exists, tmpfs)),  # [to, to, ...]
        },
        "dev_from_sys_uevent": {},                 # { name: { uevent_field: [regex], ... }, ... }
        "environment": env,
        "arguments": args
    }

def realpathwhich(v):
    path = which(v)
    if path:
        return realpath(path)
    return v

def expand(v, ctx=environ):
    return Template(expanduser(v)).substitute(defaultdict(str, ctx))

def split_path(v):
    buf = ""
    res = []

    for c in v:
        if c == sep:
            if len(buf) > 0:
                res.append(buf)
                buf = ""
            res.append(c)
        else:
            buf += c

    if len(buf) > 0:
        res.append(buf)

    return res

def merge(source, destination, mode="expand"):
    if mode not in set(["expand", "replace"]):
        raise RuntimeError("unsupported mode {}, it could be expand or replace".format(mode))
    for key, value in source.items():
        if isinstance(value, dict):
            node = destination.setdefault(key, {})
            merge(value, node, mode=mode)
        elif isinstance(value, list) and mode == "expand":
            destination[key] = value + destination.get(key, [])
        else:
            destination[key] = value
    return destination

def get_user(user):
    p = getpwnam(user)
    return {
        "user": p.pw_name,
        "uid": p.pw_uid,
        "gid": p.pw_gid
    }

def json_marshal_pretty_str(v):
    return json_marshal_str(v, indent=4)

def split_mount_suffix(v):
    for suffix in mount_suffixes:
        delimited = ":" + suffix
        if v.endswith(delimited):
            return (
                v[:-len(delimited)],
                suffix,
            )
    return (v, None)

def sorted_mounts(mounts):
    ms = []
    for k, v in mounts.items():
        for mount in v:
            ms.append((k, mount,))

    ws = {}
    for k1, p1 in enumerate(ms):
        w = []

        for k2, p2 in enumerate(ms):
            if k1 == k2:
                continue

            p1s = split_path(p1[1][1])
            p2s = split_path(p2[1][1])
            n = 0

            for v in p2s:
                if len(p1s) <= n or len(p2s) <= n:
                    break
                if v == p1s[n]:
                    n += 1
                else:
                    break

            if len(p1s) > len(p2s):
                n += 1

            w.append(n)

        ws[p1] = max(w)

    return map(
        lambda v: v[1],
        sorted(
            [(v, k,) for k, v in ws.items()],
            key=lambda v: v[0]
        )
    )

def setup_way_secure(config, sync_fds=None, app_id=None):
    command = realpathwhich("way-secure")

    xdg_runtime_dir = Path(environ.get("XDG_RUNTIME_DIR", "/run/user/{UID}".format(**environ)))
    socket_dir = xdg_runtime_dir / ".nix-cage-wayland"
    socket_dir.mkdir(exist_ok=True)
    _, security_context_socket = tempfile.mkstemp(prefix="security-context-", dir=socket_dir)

    wayland_display = environ.get("WAYLAND_DISPLAY", "wayland-0")
    config["mounts"]["ro"].append((
        security_context_socket,
        str(xdg_runtime_dir / wayland_display),
        "f"
    ))
    config["environment"]["WAYLAND_DISPLAY"] = wayland_display

    if not sync_fds:
        sync_fds = make_sync_fd()

    (r_ready_fd, w_ready_fd) = os.pipe()
    os.set_inheritable(w_ready_fd, True)

    args = [
        "--socket-path", security_context_socket,
        "--sandbox-engine", basename(__file__),
        "--app-id", str(app_id),
        "--instance-id", bytes.hex(os.urandom(5)),
        "--close-fd",  str(sync_fds.w_fd),
        "--ready-fd",  str(w_ready_fd),
    ]
    print(' '.join([basename(command)] + args), file=stderr)

    try:
        max_retries = 42
        retries = 1
        while True:
            try:
                is_fd_valid(sync_fds.w_fd)
                os.unlink(security_context_socket)
                with subprocess.Popen(
                        [command] + args,
                        pass_fds=(sync_fds.w_fd, w_ready_fd),
                        stderr=subprocess.STDOUT,
                        stdout=subprocess.PIPE
                ) as p:
                    out, _ = p.communicate()
                    if p.returncode != 0:
                        raise RuntimeError("Creating wayland security context failed with return code {}:\n{}: {}"
                                           .format(p.returncode, basename(command), out.decode('utf8')))

                is_fd_valid(r_ready_fd)
                print("Waiting for {}...".format(basename(command)))
                ready_resp = os.read(r_ready_fd, 1)
                if ready_resp != b'\n':
                    raise RuntimeError("Unexpected return value in ready_fd: {}".format(ready_resp))

                is_fd_valid(sync_fds.r_fd)
                is_fd_valid(sync_fds.w_fd)
                check_wayland_security_context(security_context_socket)

                break
            except WaylandSecurityContextException:
                if retries <= max_retries:
                    # Not clear whether its better to just do many retries fast, rather than few retries
                    # with a backoff delay. So just do something kinda in between.
                    delay_secs = 0.1 * 1.05 ** retries
                    print("Failed to get a valid Wayland security context, retrying in {:.2}s...".format(delay_secs))
                    time.sleep(delay_secs)
                    retries = retries + 1
                else:
                    print("Giving up.")
                    raise
    except:  # noqa: E722
        os.unlink(security_context_socket)
        os.close(sync_fds.r_fd)
        os.close(sync_fds.w_fd)
        raise
    finally:
        os.close(w_ready_fd)
        os.close(r_ready_fd)

    return (sync_fds, security_context_socket)

class WaylandSecurityContextException(Exception):
    """Invalid Wayland security context socket"""

def check_wayland_security_context(security_context_socket):
    check_command = realpathwhich("wayland-info")
    if Path(check_command).exists():
        xdg_runtime_dir = Path(environ.get("XDG_RUNTIME_DIR", "/run/user/{UID}".format(**environ)))
        with subprocess.Popen(
                [check_command],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                env={"WAYLAND_DISPLAY": security_context_socket,
                     "XDG_RUNTIME_DIR": xdg_runtime_dir}
        ) as p:
            out, err = p.communicate()
            if p.returncode != 0:
                raise WaylandSecurityContextException(
                    "Checking wayland security context socket failed with return code {}:\n{}: {}"
                    .format(p.returncode, basename(check_command), err.decode('utf8'))
                )

            # Nested security contexts are forbidden by the protocol, so this should suffice to
            # make sure we actually have a proper security context.
            if "wp_security_context_manager_v1" in out.decode('utf8'):
                raise RuntimeError("Invalid wayland security context, allows access to wp_security_context_manager_v1!")

def setup_dbus_proxy(config, sync_fds=None):
    command = realpathwhich("xdg-dbus-proxy")

    system_rules = []
    session_rules = []
    other_rules = defaultdict(list)
    for policy in ["see", "talk", "own", "call", "broadcast"]:
        if config["dbus"]["system"] and config["dbus"]["system"][policy]:
            for rule in set(config["dbus"]["system"][policy]):
                system_rules.extend(["--{}={}".format(policy, rule)])

        if config["dbus"]["session"] and config["dbus"]["session"][policy]:
            for rule in set(config["dbus"]["session"][policy]):
                session_rules.extend(["--{}={}".format(policy, rule)])

        other_buses = (
            (k, v.get(policy, [])) for k, v in config["dbus"].items()
            if k not in ["session", "system"] and v.get(policy, []) and exists(k)
        )
        for (bus_path, rules) in other_buses:
            for rule in set(rules):
                other_rules[bus_path].extend(["--{}={}".format(policy, rule)])

    if not (system_rules or session_rules or other_rules):
        return sync_fds

    xdg_runtime_dir = Path(environ.get("XDG_RUNTIME_DIR", "/run/user/{UID}".format(**environ)))
    proxy_bus_dir = xdg_runtime_dir / ".nix-cage-dbus-proxy"
    proxy_bus_dir.mkdir(exist_ok=True)

    system_bus = Path("/run/dbus/system_bus_socket")
    session_bus = environ.get("DBUS_SESSION_BUS_ADDRESS")

    if not sync_fds:
        sync_fds = make_sync_fd()
    args = ["--fd={}".format(sync_fds.w_fd)]

    system_proxy_bus = None
    if system_rules and system_bus.exists():
        _, system_proxy_bus = tempfile.mkstemp(prefix="system-bus-proxy", dir=proxy_bus_dir)

        # Add mount to config for binding proxy bus to system bus.
        config["mounts"]["ro"].append((system_proxy_bus, str(system_bus), "f"))

        args.extend(["unix:path={}".format(system_bus), system_proxy_bus])
        if config["dbus"]["system"].get("log", False):
            args.append("--log")
        if config["dbus"]["system"].get("sloppy-names", False):
            args.append("--sloppy-names")
        args.extend(["--filter"] + system_rules)

    session_proxy_bus = None
    if session_rules and session_bus:
        _, session_proxy_bus = tempfile.mkstemp(prefix="session-bus-proxy", dir=proxy_bus_dir)

        # Add mount to config for binding proxy bus to session bus.
        bus_path = str(xdg_runtime_dir / "session_bus")
        config["mounts"]["ro"].append((session_proxy_bus, bus_path, "f"))
        config["environment"]["DBUS_SESSION_BUS_ADDRESS"] = 'unix:path={}'.format(bus_path)

        args.extend([session_bus, session_proxy_bus])
        if config["dbus"]["session"].get("log", False):
            args.append("--log")
        if config["dbus"]["session"].get("sloppy-names", False):
            args.append("--sloppy-names")
        args.extend(["--filter"] + session_rules)

    proxy_buses = []
    for (bus_path, rules) in other_rules.items():
        _, proxy_bus = tempfile.mkstemp(prefix="bus-proxy", dir=proxy_bus_dir)
        proxy_buses.append(proxy_bus)

        # Add mount to config for binding proxy bus to the bus.
        config["mounts"]["ro"].append((proxy_bus, bus_path, "f"))

        args.extend(['unix:path={}'.format(bus_path), proxy_bus])
        if config["dbus"][bus_path].get("log", False):
            args.append("--log")
        if config["dbus"][bus_path].get("sloppy-names", False):
            args.append("--sloppy-names")
        args.extend(["--filter"] + rules)

    print(' '.join([basename(command)] + args), file=stderr)
    try:
        args_fd = make_args_memfd(args)
        is_fd_valid(sync_fds.w_fd)
        subprocess.Popen(
            [basename(command)] + ["--args={}".format(args_fd)],
            pass_fds=(sync_fds.w_fd, args_fd)
        )

        # xdg-dbus-proxy writes b'x' to the sync_fd once it's ready, so we check that as well.
        print("Waiting for {}...".format(basename(command)))
        is_fd_valid(sync_fds.r_fd)
        ready_resp = os.read(sync_fds.r_fd, 1)
        if ready_resp != b'x':
            raise RuntimeError("{}: Unexpected return value in ready_fd: {}".format(command, ready_resp))
    except:  # noqa: E722
        if session_proxy_bus:
            os.unlink(session_proxy_bus)
        if system_proxy_bus:
            os.unlink(system_proxy_bus)
        for pb in proxy_buses:
            os.unlink(pb)
        os.close(sync_fds.r_fd)
        os.close(sync_fds.w_fd)
        raise

    return sync_fds

def make_args_memfd(args, name="args"):
    args_fd = os.memfd_create(name, os.MFD_CLOEXEC | os.MFD_ALLOW_SEALING)
    for a in args:
        os.write(args_fd, str(a).encode() + b'\x00')
    fcntl.fcntl(
        args_fd,
        fcntl.F_ADD_SEALS,
        fcntl.F_SEAL_SHRINK | fcntl.F_SEAL_GROW | fcntl.F_SEAL_WRITE | fcntl.F_SEAL_SEAL
    )
    os.lseek(args_fd, 0, os.SEEK_SET)

    return args_fd

class SyncFds(NamedTuple):
    r_fd: int
    w_fd: int

# Set up file descriptor for syncing external sandboxing utils termination with bwrap. Use pipe,
# as bwrap calls close() on the fd on exit, while the external utils simply wait until the fd is
# closed (other option would be to use a socket pair).
#
# Reader (r_fd) goes to bwrap, while the writer (w_fd) is shared by the external utils.
def make_sync_fd():
    (r_fd, w_fd) = os.pipe()
    os.set_inheritable(r_fd, True)
    os.set_inheritable(w_fd, True)
    return SyncFds(r_fd, w_fd)

# Raise OSError if fd is not valid.
def is_fd_valid(fd):
    # cheaper than os.fstat / os.stat
    #
    # returns 0 if inheritable, 1 == fcntl.FD_CLOEXEC
    fcntl.fcntl(fd, fcntl.F_GETFD)

def get_dev_paths(dev_from_sys_uevent):
    import re
    expect_groups = defaultdict(set)
    patterns = []
    for name, p in dev_from_sys_uevent.items():
        device_pat = []
        for field in p.keys():
            if p[field]:
                group = name + field
                expect_groups[name].add(group)
                device_pat.append(r"^{}=(?P<{}>{})$".format(field, group, '|'.join(p[field])))
        if device_pat:
            expect_groups[name].add(name)
            patterns.append(r"(?P<{}>{})".format(name, '|'.join(device_pat)))

    if patterns:
        # TBH could just loop patterns and try to match each with re.search(), instead of making
        # a single mega-regexp.
        pat = re.compile('|'.join(patterns), re.MULTILINE)
        devices = (
            (d, (d / "device" / "uevent").read_text())
            for d in Path("/sys/dev/char/").iterdir()
            if (d / "device" / "uevent").exists()
        )

        for (d, uevent) in devices:
            matched_groups = set(
                group_name
                for m in re.finditer(pat, uevent)
                for group_name, group_match in m.groupdict().items()
                if group_match is not None
            )

            if matched_groups and expect_groups[min(matched_groups, key=len)] == matched_groups:
                dev_char = Path("/dev/char") / d.name
                if dev_char.is_symlink():
                    yield dev_char.resolve(strict=True)
                yield dev_char

def make_command(config):
    bwrap = realpathwhich("bwrap")

    mounts = list(reduce(lambda acc, v: acc + v,
                         map(lambda v: (
                             ["--ro-bind"            ] + list(v[1][:2]) if v[0] == "ro"
                             else ["--bind"          ] + list(v[1][:2]) if v[0] == "rw"
                             else ["--tmpfs", v[1][1]]                  if v[0] == "tmpfs"
                             else []
                         ), sorted_mounts(config["mounts"])), []))

    # Scan /sys/dev/char/*/device/uevent for entries matching the patterns in config, and --dev-bind
    # the corresponding /dev entries.
    if config["dev_from_sys_uevent"]:
        config["mounts"]["dev"].extend(
            (str(p), str(p))
            for p in get_dev_paths(config["dev_from_sys_uevent"])
        )

    dev_mounts = list(reduce(
        lambda acc, v: acc + v,
        map(lambda v: (
            ["--dev-bind"] + list(v[1][:2]) if v[0] == "dev" and Path(v[1][:2][0]).exists()
            else []
        ), sorted_mounts(config["mounts"])), []
    ))

    env = list(reduce(lambda acc, kv: acc + ["--setenv"] + list(kv),
                      config["environment"].items(), []))

    bwrap_devtmpfs = config["arguments"]["devtmpfs"]
    bwrap_flags = config["arguments"]["bwrap"]

    if Path("flake.nix").exists() \
       or any((p / "flake.nix").exists() for p in Path().resolve().parents):
        shell = which("nix")
        if shell is None:
            raise RuntimeError("Could not find executable: nix")
        shell_flags = ["develop"] + config["arguments"]["nix-develop"] + [
            "--command", config["arguments"]["command"],
        ]
    else:
        shell = which(environ.get("SHELL", "bash"))
        if shell is None:
            raise RuntimeError("No SHELL defined and could not find executable: bash")
        shell_flags = ["-c", config["arguments"]["command"]] if config["arguments"]["command"] \
            else []

    bwrap_args = mounts + bwrap_devtmpfs + dev_mounts + env + bwrap_flags
    print(' '.join([basename(bwrap)] + bwrap_args + ["--", shell] + shell_flags), file=stderr)

    args_fd = make_args_memfd(bwrap_args)
    os.set_inheritable(args_fd, True)
    argv = [basename(bwrap), "--args", str(args_fd)] + ["--", shell] + shell_flags

    return bwrap, argv

def load_config(config, arguments, rest):
    if exists(arguments["config"]):
        with open(arguments["config"], "r") as stream:
            overlay_config = json_unmarshal(stream)
            config = merge(overlay_config, config, mode=overlay_config.get("mode", config["mode"]))

    ##

    if arguments["command"]:
        config["arguments"]["command"] = arguments["command"]

    config["arguments"]["bwrap"] += rest
    for path in arguments["path"]:
        path, suffix = split_mount_suffix(path)
        if not suffix:
            suffix = "rw"
        if suffix == "tmpfs":
            config["mounts"][suffix].append(path)
        else:
            config["mounts"][suffix].append((path, path,))

    ##

    def expand_mount(v):
        return (abspath(expand(v[0])), abspath(expand(v[1])),) + tuple(v[2:])

    for k, v in config["mounts"].items():
        config["mounts"][k] = [
            expand_mount((v, v,) if type(v) is str else v)
            for v in config["mounts"][k]
        ]
    for k, v in config["environment"].items():
        config["environment"][k] = expand(v)

    return config

def ensure_prerequisites(config):
    initializers = {
        "d": lambda item: Path(item[0]).mkdir(parents=True, exist_ok=True),
        "f": lambda item: Path(item[0]).touch(exist_ok=True),
    }

    for _, v in config["mounts"].items():
        for item in v:
            if len(item) == 3:
                init = initializers.get(item[2])
                if init is not None:
                    init(item)

def main(arguments, rest=[]):
    user = get_user(environ["USER"])
    environ["UID"] = str(user["uid"])
    environ["GID"] = str(user["gid"])

    arguments["cd"] = abspath(expanduser(arguments["cd"]))
    chdir(arguments["cd"])

    config = load_config(get_default_config(), arguments, rest)

    if arguments["show_config"]:
        print(json_marshal_pretty_str(config))
        return

    ensure_prerequisites(config)

    seccomp_fd = None
    if arguments["seccomp"] and exists(arguments["seccomp"]):
        seccomp_fd = os.open(abspath(expanduser(arguments["seccomp"])), os.O_RDONLY)
        os.set_inheritable(seccomp_fd, True)
        config["arguments"]["bwrap"].append("--seccomp")
        config["arguments"]["bwrap"].append("{}".format(seccomp_fd))

    if arguments["proc"]:
        config["arguments"]["bwrap"].append("--proc")
        config["arguments"]["bwrap"].append(arguments["proc"])

    if arguments["devtmpfs"]:
        config["arguments"]["devtmpfs"].append("--dev")
        config["arguments"]["devtmpfs"].append(arguments["devtmpfs"])

    if arguments["ro_root"]:
        config["arguments"]["bwrap"].append("--remount-ro")
        config["arguments"]["bwrap"].append("/")

    sync_fds = setup_dbus_proxy(config, None)

    security_context_socket = None
    if arguments["wayland"]:
        (sync_fds, security_context_socket) = setup_way_secure(config, sync_fds, app_id=arguments["config"])

    if sync_fds:
        config["arguments"]["bwrap"].extend(["--sync-fd", "{}".format(sync_fds.r_fd)])

    command, argv = make_command(config)

    # Double check that sync_fds is still functional.
    is_fd_valid(sync_fds.r_fd)
    is_fd_valid(sync_fds.w_fd)

    if arguments["wayland"]:
        check_wayland_security_context(security_context_socket)

    execve(command, argv, environ)


if __name__ == "__main__":
    p = ArgumentParser(
        description="Nix-cage, sandboxed environments with nix develop"
    )

    p.add_argument(
        "path",
        nargs="*",
        help=(
            "One or more directories or files which will be mounted into the sandbox. "
            "Paths inside sandbox are same as in host system. "
            "Mounts are read/write by default, but you could change this by appending one "
            "of {} suffixes to the path.".format(
                "|".join([":" + v for v in mount_suffixes])
            )
        )
    )
    p.add_argument("--config", help="config file path", default="nix-cage.json")
    p.add_argument("--command", help="command to execute inside the sandbox")
    p.add_argument("--seccomp", help="compiled seccomp BPF file")
    p.add_argument("--proc", help="mount procfs to PROC")
    p.add_argument("--devtmpfs", help="mount a new devtmpfs to DEVTMPFS")
    p.add_argument("--wayland", help="setup a Wayland security context", action="store_true")
    p.add_argument("--ro-root", help="read only root", action="store_true")
    p.add_argument("--show-config", help="dumps config in JSON and exit", action="store_true")
    p.add_argument("--cd", "-C", help="change to directory before doing anything", default=getcwd())

    arguments, rest = p.parse_known_args()
    main(arguments.__dict__, rest)
