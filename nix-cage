#!/usr/bin/env python
import os
import subprocess
import tempfile
import fcntl
from argparse import ArgumentParser
from pathlib import Path
from os import execve, getcwd, chdir
from os.path import abspath, expanduser, basename, realpath, exists
from shutil import which
from os import environ, sep
from sys import stderr
from functools import reduce
from json import load as json_unmarshal, dumps as json_marshal_str
from pwd import getpwnam
from string import Template
from collections import defaultdict

mount_suffixes = [
    "ro",
    "rw",
    "dev",
    "tmpfs"
]

def get_default_config():
    rw = ["."]
    ro = ["/"]
    dev = []
    tmpfs = [
        "/tmp",
        "/home",
        "/run/user",
        "/run/media",
        "/tmp/.private",
    ]

    xdg_runtime_dir = environ.get("XDG_RUNTIME_DIR")
    if xdg_runtime_dir and exists(xdg_runtime_dir):
        tmpfs.append(xdg_runtime_dir)
    else:
        tmpfs.extend(["/run/user/{UID}".format(**environ)]  if "UID"  in environ else [])

    tmpfs.extend(["/run/media/{USER}".format(**environ)]    if "USER" in environ else [])
    tmpfs.extend(["/tmp/.private/{USER}".format(**environ)] if "USER" in environ else [])

    def set_from_env(k, r, key=None):
        if k in environ:
            r[key or k] = environ[k]

    env = {}
    set_from_env("HOME", env)
    set_from_env("TERM", env)
    set_from_env("SHELL", env)
    set_from_env("NIX_REMOTE", env)
    set_from_env("DBUS_SESSION_BUS_ADDRESS", env)
    set_from_env("XDG_RUNTIME_DIR", env)

    if "NIX_REMOTE" not in env:
        nix_local = [
            environ.get("NIX_STORE_DIR", "/nix/store"),
            environ.get("NIX_LOG_DIR",   "/nix/var/log/nix"),
            environ.get("NIX_STATE_DIR", "/nix/var/nix"),
        ]
        rw.extend(list(filter(exists, nix_local)))

    args = {
        "devtmpfs": [],
        "bwrap": [
            "--new-session",
            "--die-with-parent",
            "--unshare-ipc",
            "--unshare-cgroup",
            "--unshare-uts",
            "--unshare-pid",
            "--hostname", "localhost"
        ],
        "nix-develop": [],
    }
    set_from_env("SHELL", args, key="command")

    return {
        "mode": "expand",
        "dbus": {
            "system": {
                "see": [],
                "talk": [],
                "own": [],
                "call": [],
                "broadcast": [],
            },
            "session": {
                "see": [],
                "talk": [],
                "own": [],
                "call": [],
                "broadcast": [],
            },
        },
        "mounts": {
            "rw":    rw,                           # [(from, to), (from, to), ...] | [to, to, ...]
            "ro":    ro,                           # [(from, to), (from, to), ...] | [to, to, ...]
            "dev":   dev,                          # [(from, to), (from, to), ...] | [to, to, ...]
            "tmpfs": list(filter(exists, tmpfs)),  # [to, to, ...]
        },
        "environment": env,
        "arguments": args
    }

def realpathwhich(v):
    path = which(v)
    if path:
        return realpath(path)
    return v

def expand(v, ctx=environ):
    return Template(expanduser(v)).substitute(defaultdict(str, ctx))

def split_path(v):
    buf = ""
    res = []

    for c in v:
        if c == sep:
            if len(buf) > 0:
                res.append(buf)
                buf = ""
            res.append(c)
        else:
            buf += c

    if len(buf) > 0:
        res.append(buf)

    return res

def merge(source, destination, mode="expand"):
    if mode not in set(["expand", "replace"]):
        raise RuntimeError("unsupported mode {}, it could be expand or replace".format(mode))
    for key, value in source.items():
        if isinstance(value, dict):
            node = destination.setdefault(key, {})
            merge(value, node, mode=mode)
        elif isinstance(value, list) and mode == "expand":
            destination[key] = value + destination.get(key, [])
        else:
            destination[key] = value
    return destination

def get_user(user):
    p = getpwnam(user)
    return {
        "user": p.pw_name,
        "uid": p.pw_uid,
        "gid": p.pw_gid
    }

def json_marshal_pretty_str(v):
    return json_marshal_str(v, indent=4)

def split_mount_suffix(v):
    for suffix in mount_suffixes:
        delimited = ":" + suffix
        if v.endswith(delimited):
            return (
                v[:-len(delimited)],
                suffix,
            )
    return (v, None)

def sorted_mounts(mounts):
    ms = []
    for k, v in mounts.items():
        for mount in v:
            ms.append((k, mount,))

    ws = {}
    for k1, p1 in enumerate(ms):
        w = []

        for k2, p2 in enumerate(ms):
            if k1 == k2:
                continue

            p1s = split_path(p1[1][1])
            p2s = split_path(p2[1][1])
            n = 0

            for v in p2s:
                if len(p1s) <= n or len(p2s) <= n:
                    break
                if v == p1s[n]:
                    n += 1
                else:
                    break

            if len(p1s) > len(p2s):
                n += 1

            w.append(n)

        ws[p1] = max(w)

    return map(
        lambda v: v[1],
        sorted(
            [(v, k,) for k, v in ws.items()],
            key=lambda v: v[0]
        )
    )

def setup_way_secure(config, sync_fds=None, app_id=None):
    from socket import socket, AF_UNIX, SOCK_STREAM
    command = realpathwhich("way-secure")

    xdg_runtime_dir = Path(environ.get("XDG_RUNTIME_DIR", "/run/user/{UID}".format(**environ)))
    socket_dir = xdg_runtime_dir / ".nix-cage-wayland"
    socket_dir.mkdir(exist_ok=True)
    _, security_context_socket = tempfile.mkstemp(prefix="security-context", dir=socket_dir)

    sock = socket(family=AF_UNIX, type=SOCK_STREAM)
    os.unlink(security_context_socket)
    sock.bind(security_context_socket)
    sock.listen()
    sock.set_inheritable(True)
    sock_fd = sock.fileno()

    wayland_display = environ.get("WAYLAND_DISPLAY", "wayland-0")
    config["mounts"]["ro"].append((
        security_context_socket,
        str(xdg_runtime_dir / wayland_display),
        "f"
    ))
    config["environment"]["WAYLAND_DISPLAY"] = wayland_display

    if not sync_fds:
        sync_fds = make_sync_fd()
    (_, w_fd) = sync_fds

    args = [
        "--socket-fd", str(sock_fd),
        "--sandbox-engine", basename(__file__),
        "--app-id", str(app_id),
        "--close-fd",  str(w_fd)
    ]
    print(' '.join([basename(command)] + args), file=stderr)
    try:
        subprocess.Popen([basename(command)] + args, pass_fds=(w_fd, sock_fd))
    except:
        sock.close()
        os.unlink(security_context_socket)
        (r_fd, w_fd) = sync_fds
        os.close(r_fd)
        os.close(w_fd)
        raise

    return sync_fds

def setup_dbus_proxy(config, sync_fds=None):
    command = realpathwhich("xdg-dbus-proxy")

    system_rules = []
    session_rules = []
    other_rules = defaultdict(list)
    for policy in ["see", "talk", "own", "call", "broadcast"]:
        if config["dbus"]["system"] and config["dbus"]["system"][policy]:
            for rule in set(config["dbus"]["system"][policy]):
                system_rules.extend(["--{}={}".format(policy, rule)])

        if config["dbus"]["session"] and config["dbus"]["session"][policy]:
            for rule in set(config["dbus"]["session"][policy]):
                session_rules.extend(["--{}={}".format(policy, rule)])

        other_buses = (
            (k, v.get(policy, [])) for k, v in config["dbus"].items()
            if k not in ["session", "system"] and v.get(policy, []) and exists(k)
        )
        for (bus_path, rules) in other_buses:
            for rule in set(rules):
                other_rules[bus_path].extend(["--{}={}".format(policy, rule)])

    if not (system_rules or session_rules or other_rules):
        return sync_fds

    xdg_runtime_dir = Path(environ.get("XDG_RUNTIME_DIR", "/run/user/{UID}".format(**environ)))
    proxy_bus_dir = xdg_runtime_dir / ".nix-cage-dbus-proxy"
    proxy_bus_dir.mkdir(exist_ok=True)

    system_bus = Path("/run/dbus/system_bus_socket")
    session_bus = environ.get("DBUS_SESSION_BUS_ADDRESS")

    if not sync_fds:
        sync_fds = make_sync_fd()
    (_, w_fd) = sync_fds
    args = ["--fd={}".format(w_fd)]

    system_proxy_bus = None
    if system_rules and system_bus.exists():
        _, system_proxy_bus = tempfile.mkstemp(prefix="system-bus-proxy", dir=proxy_bus_dir)

        # Add mount to config for binding proxy bus to system bus.
        config["mounts"]["ro"].append((system_proxy_bus, str(system_bus), "f"))

        args.extend(["unix:path={}".format(system_bus), system_proxy_bus])
        if config["dbus"]["system"].get("log", False):
            args.append("--log")
        if config["dbus"]["system"].get("sloppy-names", False):
            args.append("--sloppy-names")
        args.extend(["--filter"] + system_rules)

    session_proxy_bus = None
    if session_rules and session_bus:
        _, session_proxy_bus = tempfile.mkstemp(prefix="session-bus-proxy", dir=proxy_bus_dir)

        # Add mount to config for binding proxy bus to session bus.
        bus_path = str(xdg_runtime_dir / "session_bus")
        config["mounts"]["ro"].append((session_proxy_bus, bus_path, "f"))
        config["environment"]["DBUS_SESSION_BUS_ADDRESS"] = 'unix:path={}'.format(bus_path)

        args.extend([session_bus, session_proxy_bus])
        if config["dbus"]["session"].get("log", False):
            args.append("--log")
        if config["dbus"]["session"].get("sloppy-names", False):
            args.append("--sloppy-names")
        args.extend(["--filter"] + session_rules)

    proxy_buses = []
    for (bus_path, rules) in other_rules.items():
        _, proxy_bus = tempfile.mkstemp(prefix="bus-proxy", dir=proxy_bus_dir)
        proxy_buses.append(proxy_bus)

        # Add mount to config for binding proxy bus to the bus.
        config["mounts"]["ro"].append((proxy_bus, bus_path, "f"))

        args.extend(['unix:path={}'.format(bus_path), proxy_bus])
        if config["dbus"][bus_path].get("log", False):
            args.append("--log")
        if config["dbus"][bus_path].get("sloppy-names", False):
            args.append("--sloppy-names")
        args.extend(["--filter"] + rules)

    print(' '.join([basename(command)] + args), file=stderr)
    try:
        args_fd = make_args_memfd(args)
        subprocess.Popen(
            [basename(command)] + ["--args={}".format(args_fd)],
            pass_fds=(w_fd, args_fd)
        )
    except:
        if session_proxy_bus:
            os.unlink(session_proxy_bus)
        if system_proxy_bus:
            os.unlink(system_proxy_bus)
        for pb in proxy_buses:
            os.unlink(pb)
        (r_fd, w_fd) = sync_fds
        os.close(r_fd)
        os.close(w_fd)
        raise

    return sync_fds

def make_args_memfd(args, name="args"):
    args_fd = os.memfd_create(name, os.MFD_CLOEXEC | os.MFD_ALLOW_SEALING)
    for a in args:
        os.write(args_fd, str(a).encode() + b'\x00')
    fcntl.fcntl(
        args_fd,
        fcntl.F_ADD_SEALS,
        fcntl.F_SEAL_SHRINK | fcntl.F_SEAL_GROW | fcntl.F_SEAL_WRITE | fcntl.F_SEAL_SEAL
    )
    os.lseek(args_fd, 0, os.SEEK_SET)

    return args_fd

# Set up file descriptor for syncing external sandboxing utils termination with bwrap. Use pipe,
# as bwrap calls close() on the fd on exit, while the external utils simply wait until the fd is
# closed (other option would be to use a socket pair).
#
# Reader (r_fd) goes to bwrap, while the writer (w_fd) is shared by the external utils.
def make_sync_fd():
    (r_fd, w_fd) = os.pipe()
    os.set_inheritable(r_fd, True)
    os.set_inheritable(w_fd, True)
    return (r_fd, w_fd)

def make_command(config):
    bwrap = realpathwhich("bwrap")

    mounts = list(reduce(lambda acc, v: acc + v,
                         map(lambda v: (
                             ["--ro-bind"            ] + list(v[1][:2]) if v[0] == "ro"
                             else ["--bind"          ] + list(v[1][:2]) if v[0] == "rw"
                             else ["--tmpfs", v[1][1]]                  if v[0] == "tmpfs"
                             else []
                         ), sorted_mounts(config["mounts"])), []))

    dev_mounts = list(reduce(
        lambda acc, v: acc + v,
        map(lambda v: (
            ["--dev-bind"] + list(v[1][:2]) if v[0] == "dev" and Path(v[1][:2][0]).exists()
            else []
        ), sorted_mounts(config["mounts"])), []
    ))

    env = list(reduce(lambda acc, kv: acc + ["--setenv"] + list(kv),
                      config["environment"].items(), []))

    bwrap_devtmpfs = config["arguments"]["devtmpfs"]
    bwrap_flags = config["arguments"]["bwrap"]

    if Path("flake.nix").exists() \
       or any((p / "flake.nix").exists() for p in Path().resolve().parents):
        shell = which("nix")
        shell_flags = ["develop"] + config["arguments"]["nix-develop"] + [
            "--command", config["arguments"]["command"],
        ]
    else:
        shell = which(environ.get("SHELL", "bash"))
        shell_flags = ["-c", config["arguments"]["command"]] if config["arguments"]["command"] \
            else []

    bwrap_args = mounts + bwrap_devtmpfs + dev_mounts + env + bwrap_flags
    print(' '.join([basename(bwrap)] + bwrap_args + ["--", shell] + shell_flags), file=stderr)

    args_fd = make_args_memfd(bwrap_args)
    os.set_inheritable(args_fd, True)
    argv = [basename(bwrap), "--args", str(args_fd)] + ["--", shell] + shell_flags

    return bwrap, argv

def load_config(config, arguments, rest):
    if exists(arguments["config"]):
        with open(arguments["config"], "r") as stream:
            overlay_config = json_unmarshal(stream)
            config = merge(overlay_config, config, mode=overlay_config.get("mode", config["mode"]))

    ##

    if arguments["command"]:
        config["arguments"]["command"] = arguments["command"]

    config["arguments"]["bwrap"] += rest
    for path in arguments["path"]:
        path, suffix = split_mount_suffix(path)
        if not suffix:
            suffix = "rw"
        if suffix == "tmpfs":
            config["mounts"][suffix].append(path)
        else:
            config["mounts"][suffix].append((path, path,))

    ##

    def expand_mount(v):
        return (abspath(expand(v[0])), abspath(expand(v[1])),) + tuple(v[2:])

    for k, v in config["mounts"].items():
        config["mounts"][k] = [
            expand_mount((v, v,) if type(v) is str else v)
            for v in config["mounts"][k]
        ]
    for k, v in config["environment"].items():
        config["environment"][k] = expand(v)

    return config

def ensure_prerequisites(config):
    initializers = {
        "d": lambda item: Path(item[0]).mkdir(parents=True, exist_ok=True),
        "f": lambda item: Path(item[0]).touch(exist_ok=True),
    }

    for _, v in config["mounts"].items():
        for item in v:
            if len(item) == 3:
                init = initializers.get(item[2])
                if init is not None:
                    init(item)

def main(arguments, rest=[]):
    user = get_user(environ["USER"])
    environ["UID"] = str(user["uid"])
    environ["GID"] = str(user["gid"])

    arguments["cd"] = abspath(expanduser(arguments["cd"]))
    chdir(arguments["cd"])

    config = load_config(get_default_config(), arguments, rest)

    if arguments["show_config"]:
        print(json_marshal_pretty_str(config))
        return

    ensure_prerequisites(config)

    seccomp_fd = None
    if arguments["seccomp"] and exists(arguments["seccomp"]):
        seccomp_fd = os.open(abspath(expanduser(arguments["seccomp"])), os.O_RDONLY)
        os.set_inheritable(seccomp_fd, True)
        config["arguments"]["bwrap"].append("--seccomp")
        config["arguments"]["bwrap"].append("{}".format(seccomp_fd))

    if arguments["proc"]:
        config["arguments"]["bwrap"].append("--proc")
        config["arguments"]["bwrap"].append(arguments["proc"])

    if arguments["devtmpfs"]:
        config["arguments"]["devtmpfs"].append("--dev")
        config["arguments"]["devtmpfs"].append(arguments["devtmpfs"])

    if arguments["ro_root"]:
        config["arguments"]["bwrap"].append("--remount-ro")
        config["arguments"]["bwrap"].append("/")

    sync_fds = setup_dbus_proxy(config, None)

    if arguments["wayland"]:
        sync_fds = setup_way_secure(config, sync_fds, app_id=arguments["config"])

    if sync_fds:
        (r_fd, _) = sync_fds
        config["arguments"]["bwrap"].extend(["--sync-fd", "{}".format(r_fd)])

    command, argv = make_command(config)
    execve(command, argv, environ)


if __name__ == "__main__":
    p = ArgumentParser(
        description="Nix-cage, sandboxed environments with nix develop"
    )

    p.add_argument(
        "path",
        nargs="*",
        help=(
            "One or more directories or files which will be mounted into the sandbox. "
            "Paths inside sandbox are same as in host system. "
            "Mounts are read/write by default, but you could change this by appending one "
            "of {} suffixes to the path.".format(
                "|".join([":" + v for v in mount_suffixes])
            )
        )
    )
    p.add_argument("--config", help="config file path", default="nix-cage.json")
    p.add_argument("--command", help="command to execute inside the sandbox")
    p.add_argument("--seccomp", help="compiled seccomp BPF file")
    p.add_argument("--proc", help="mount procfs to PROC")
    p.add_argument("--devtmpfs", help="mount a new devtmpfs to DEVTMPFS")
    p.add_argument("--wayland", help="setup a Wayland security context", action="store_true")
    p.add_argument("--ro-root", help="read only root", action="store_true")
    p.add_argument("--show-config", help="dumps config in JSON and exit", action="store_true")
    p.add_argument("--cd", "-C", help="change to directory before doing anything", default=getcwd())

    arguments, rest = p.parse_known_args()
    main(arguments.__dict__, rest)
